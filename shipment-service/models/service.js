const pool = require('./db'); // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –ø—É–ª –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
const contract = require('./contract'); // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –æ–ø–µ—á–∞—Ç–∫—É –≤ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
const jwt = require('jsonwebtoken');
const TronWeb = require('tronweb');
const tronWeb = new TronWeb({ fullHost: 'https://nile.trongrid.io' });
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const { error } = require('console');
let TRX_RATE;

async function getTrxRate() {
    try {
        // 1Ô∏è‚É£ CryptoCompare
        const response = await axios.get('https://min-api.cryptocompare.com/data/price?fsym=TRX&tsyms=USD');
        TRX_RATE = parseFloat(response.data.USD);
        return { source: 'CryptoCompare', rate: response.data.USD };
    } catch (error) {
        console.log('CryptoCompare –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—Ä–æ–±—É–µ–º CoinGecko...');
    }

    try {
        // 2Ô∏è‚É£ CoinGecko
        const response = await axios.get('https://api.coingecko.com/api/v3/simple/price?ids=tron&vs_currencies=usd');
        TRX_RATE = parseFloat(response.data.tron.usd);
        return { source: 'CoinGecko', rate: response.data.tron.usd };
    } catch (error) {
        console.log('CoinGecko –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—Ä–æ–±—É–µ–º Binance...');
    }

    try {
        // 3Ô∏è‚É£ Binance
        const response = await axios.get('https://api.binance.com/api/v3/ticker/price?symbol=TRXUSDT');
        TRX_RATE = parseFloat(response.data.price);
        return { source: 'Binance', rate: parseFloat(response.data.price) };
    } catch (error) {
        console.log('Binance —Ç–æ–∂–µ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.');
    }

    return { error: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å TRX' };
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–ø–∞–Ω–∏–∏
async function createCompany(name, description) {
    const query = `
        INSERT INTO companies (name, description)
        VALUES ($1, $2)
        RETURNING *;
    `;
    try {
        const result = await pool.query(query, [name, description]);
        return result.rows[0]; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—É—é –∑–∞–ø–∏—Å—å
    } catch (error) {
        console.error('Error creating company:', error);
        throw error;
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞
async function createSupplier(name, description) {
    const query = `
        INSERT INTO suppliers (name, description)
        VALUES ($1, $2)
        RETURNING *;
    `;
    try {
        const result = await pool.query(query, [name, description]);
        return result.rows[0]; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—É—é –∑–∞–ø–∏—Å—å
    } catch (error) {
        console.error('Error creating supplier:', error);
        throw error;
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏
async function createShipment(companyId, supplierId, fiatAmount, status, handler, name, description) {
    const shipmentUuid = uuidv4(); // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è UUID

    await getTrxRate();

    let trxAmount = (parseFloat(fiatAmount) / TRX_RATE).toFixed(6)

    try {
        // –ü–æ–ª—É—á–µ–Ω–∏–µ wallet_address –∏–∑ —Ç–∞–±–ª–∏—Ü—ã suppliers
        const supplierQuery = `
            SELECT wallet_address FROM suppliers WHERE id = $1;
        `;
        const supplierResult = await pool.query(supplierQuery, [supplierId]);
        if (supplierResult.rows.length === 0) {
            throw new Error('Supplier not found');
        }

        // –í—Å—Ç–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ —Ç–∞–±–ª–∏—Ü—É shipments
        const query = `
            INSERT INTO shipments (uuid, company_id, supplier_id, fiat_amount, fiat_currency, crypto_amount, status, handler, name, description)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            RETURNING *;
        `;
        const result = await pool.query(query, [
            shipmentUuid,
            companyId,
            supplierId,
            fiatAmount,
            'USD',
            trxAmount,
            status,
            handler,
            name,
            description
        ]);
        const createdShipment = result.rows[0];

        console.log(process.env.OUR_WALLET)

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ç–æ–∫–µ–Ω–æ–º
        return {
            shipmentId: createdShipment.id,
            payWallet: process.env.OUR_WALLET,
            sendTrxSumm: trxAmount,
            sendUsdtSumm: fiatAmount,
            message: 'Shipment created and waiting for transaction'
        };
    } catch (error) {
        console.error('Error creating shipment:', error);
        throw error;
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
async function createTransaction(shipmentId, blockchainTxId) {
    try {
        const checkQuery = `
            SELECT id FROM transactions WHERE blockchain_tx_id = $1
        `;

        const checkResult = await pool.query(checkQuery, [blockchainTxId]);

        const shipmentQuery = `
            SELECT * FROM shipments WHERE id = $1
        `;

        const shipmentResult = await pool.query(shipmentQuery, [shipmentId]);
        if (shipmentResult.rows.length === 0) {
            console.error('Shipment not found');
            return { error: 'Shipment not found' };
        }

        const trxAmount = shipmentResult.rows[0].crypto_amount;
        const usdtAmount = shipmentResult.rows[0].fiat_amount;

        console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:', checkResult.rows);

        if (checkResult.rows.length > 0 ){
            throw new Error('–≠—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É–∂–µ –±—ã–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ —Ä–∞–Ω–µ–µ');
        }

        const result = await checkTx(blockchainTxId, trxAmount, usdtAmount);

        console.log('‚ú® –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:', result);

        if (result.error) {
            throw new Error(result.error);
        }
        
        const transactionQuery = `
            INSERT INTO transactions (shipment_id, amount, blockchain_tx_id, token_name)
            VALUES ($1, $2, $3, $4)
            RETURNING *;
        `;

        const transactionResult = await pool.query(transactionQuery, [
            shipmentId,
            result.amount,
            blockchainTxId,
            result.currency,
        ]);

        let cryptoToAdd;
        if(result.currency == 'USDT') {
            cryptoToAdd = (parseFloat(usdtAmount) / TRX_RATE).toFixed(6);
        } else {
            cryptoToAdd = trxAmount;
        }
        
        console.log('üí∞ –î–æ–±–∞–≤–ª—è–µ–º–∞—è –∫—Ä–∏–ø—Ç–æ-—Å—É–º–º–∞:', cryptoToAdd);
        
        const processResult = await processShipment(shipmentId, blockchainTxId, cryptoToAdd, usdtAmount);

        console.log('üì¶ –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ—Å—Ç–∞–≤–∫–∏:', processResult);
        
        return { 
            success: true, 
            transaction: transactionResult.rows[0], 
            shipment: processResult 
        };
    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:', error);
        throw error;
    }
}

const tokenMap = {
    'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t': 'USDT'
};

async function checkTx(blockchainTxId, trxAmount, usdtAmount) {
    const ourWallet = process.env.OUR_WALLET;

    try {
        const { data } = await axios.post(
            'https://nile.trongrid.io/walletsolidity/gettransactionbyid',
            { value: blockchainTxId }
        );

        if (!data.raw_data) {
            console.log('–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞');
            return { error: '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞' };
        }

        const contract = data.raw_data.contract[0];
        const { type, parameter: { value } } = contract;

        if (type === 'TriggerSmartContract') {
            const contractAddress = tronWeb.address.fromHex(value.contract_address);

            const dataHex = value.data;
            const toAddressHex = '41' + dataHex.substr(8 + 24, 40);
            const to = tronWeb.address.fromHex(toAddressHex);

            const amountHex = dataHex.substr(8 + 64, 64);
            const amount = parseInt(amountHex, 16) / 1_000_000_000;

            const tokenName = tokenMap[contractAddress] || `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω (contract: ${contractAddress})`;

            if (tokenName !== 'USDT') {
                return { error: '–ù–µ –≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω' };
            }

            if (to !== ourWallet) {
                return { error: '–ù–µ —Ç–æ—Ç –∫–æ—à–µ–ª–µ–∫' };
            }

            if (parseFloat(usdtAmount) > parseFloat(amount)) {
                return { error: '–ù–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤' };
            }

            return { success: true, amount, currency: 'USDT' };

        } else if (type === 'TransferContract') {
            console.log(1)
            const to = tronWeb.address.fromHex(value.to_address);
            const amount = value.amount / 1_000_000;
            console.log(trxAmount)

            if (to !== ourWallet) {
                return { error: '–ù–µ —Ç–æ—Ç –∫–æ—à–µ–ª–µ–∫' };
            }

            if (parseFloat(trxAmount) > parseFloat(amount)) {
                return { error: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤' };
            }

            return { success: true, amount, currency: 'TRX' };

        } else {
            return { error: `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞: ${type}` };
        }

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:', error.message);
        return { error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∏–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏' };
    }
}

async function processShipment(shipmentId, txHash, cryptoToAdd, fiatToAdd) {
    try {
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        const shipmentQuery = `SELECT * FROM shipments WHERE id = $1`;
        const shipmentResult = await pool.query(shipmentQuery, [shipmentId]);

        if (shipmentResult.rowCount === 0) {
            throw new Error('Shipment not found');
        }

        const shipment = shipmentResult.rows[0];
        const shipmentUuid = shipment.uuid;

        if (!shipment.init) {
            const supplierId = shipment.supplier_id
            const companyId = shipment.company_id
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å init
            const statusQuery = `UPDATE shipments SET init = true WHERE id = $1`;
            await pool.query(statusQuery, [shipmentId]);

            const supplierQuery = `SELECT wallet_address FROM suppliers WHERE id = $1`
            const supplierResult = await pool.query(supplierQuery, [supplierId]);

            // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤ —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ
            const contractResult = await contract.registerShipment(shipmentUuid, supplierResult.rows[0].wallet_address);
            if (!contractResult.success) {
                throw new Error('Failed to register shipment in the smart contract');
            }

            const transactionResult = await contract.processPayment(txHash, shipmentUuid);
            if (!transactionResult.success) {
                throw new Error('Failed to process payment in the smart contract');
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–∞
            const token = jwt.sign(
                { shipmentUuid, companyId, supplierId },
                process.env.JWT_SECRET
            );

            return {
                shipmentUuid,
                token,
                message: 'Shipment initialized successfully',
            };
        } else {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ
            await contract.processPayment(txHash, shipmentUuid);

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É–º–º
            const updateQuery = `
                UPDATE shipments
                SET 
                    crypto_amount = crypto_amount + $1,
                    fiat_amount = fiat_amount + $2
                WHERE id = $3
            `;

            const result = await pool.query(updateQuery, [cryptoToAdd, fiatToAdd, shipmentId]);

            console.log(`–û–±–Ω–æ–≤–ª–µ–Ω–æ —Å—Ç—Ä–æ–∫: ${result.rowCount}`);

            return {
                shipmentUuid,
                message: 'Shipment transaction added successfully',
            };
        }
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤ processShipment:', error.message);
        throw error;
    }
}

async function getCompaniesAndSuppliers() {
    const companiesQuery = `
        SELECT id, name FROM companies;
    `;
    const suppliersQuery = `
        SELECT id, name FROM suppliers;
    `;

    try {
        // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å—ã –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        const companiesResult = await pool.query(companiesQuery);
        const suppliersResult = await pool.query(suppliersQuery);

        // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ç—Ä–µ–±—É–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
        const result = {
            suppliers: suppliersResult.rows.map(row => ({
                id: row.id,
                name: row.name
            })),
            companies: companiesResult.rows.map(row => ({
                id: row.id,
                name: row.name
            }))
        };

        return result;
    } catch (error) {
        console.error('Error fetching companies and suppliers:', error);
        throw error;
    }
}

async function getCompaniesAndSuppliersForShipment() {
    const companiesQuery = `
        SELECT id, name FROM companies;
    `;
    const suppliersQuery = `
        SELECT id, name FROM suppliers WHERE wallet_address IS NOT NULL;
    `;

    try {
        // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å—ã –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        const companiesResult = await pool.query(companiesQuery);
        const suppliersResult = await pool.query(suppliersQuery);

        // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ç—Ä–µ–±—É–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
        const result = {
            suppliers: suppliersResult.rows.map(row => ({
                id: row.id,
                name: row.name
            })),
            companies: companiesResult.rows.map(row => ({
                id: row.id,
                name: row.name
            }))
        };

        return result;
    } catch (error) {
        console.error('Error fetching companies and suppliers:', error);
        throw error;
    }
}

async function createEntity(type, name, description) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ–ø—É—Å—Ç–∏–º–æ—Å—Ç—å —Ç–∏–ø–∞
    if (type !== 'company' && type !== 'supplier') {
        throw new Error('Invalid type. Type must be "company" or "supplier".');
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É –∏ –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞
    const table = type === 'company' ? 'companies' : 'suppliers';
    const query = `
        INSERT INTO ${table} (name, description)
        VALUES ($1, $2)
        RETURNING *;
    `;

    try {
        // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        const result = await pool.query(query, [name, description]);
        return result.rows[0]; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—É—é –∑–∞–ø–∏—Å—å
    } catch (error) {
        console.error(`Error creating ${type}:`, error);
        throw error;
    }
}

async function getEntityData(type, entityId) {
    const table = type === 'company' ? 'companies' : 'suppliers';
    const query = `
        SELECT * FROM ${table} WHERE id = $1;
    `;
    const params = [entityId];
    const result = await pool.query(query, params);
    if (result.rows.length === 0) {
        console.error(`Entity with ID ${entityId} not found in ${table}`);
        return { error: `Entity with ID ${entityId} not found` };
    }
    return result.rows[0]; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—É—é –∑–∞–ø–∏—Å—å
}

async function updateSupplierWallet(supplierId, walletAddress) {
    const query = `
        UPDATE suppliers
        SET wallet_address = $1
        WHERE id = $2
        RETURNING *;
    `;

    try {
        const result = await pool.query(query, [walletAddress, supplierId]);
        return result.rows[0]; // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—É—é –∑–∞–ø–∏—Å—å
    } catch (error) {
        console.error(`Error updating supplier wallet:`, error);
        throw error;
    }
}


async function revokeToken(token) {
    try {
        // –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏—Å—Ç–µ—á–µ–Ω–∏—è
        const decoded = jwt.decode(token);
        const expiresAt = new Date(decoded.exp * 1000); // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–µ–∫—É–Ω–¥—ã –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã

        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –≤ —á–µ—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫
        await pool.query(
            'INSERT INTO token_blacklist (token, expires_at) VALUES ($1, $2)',
            [token, expiresAt]
        );
    } catch (error) {
        console.error('Error revoking token:', error);
        throw error;
    }
}

async function getAmountByUuid(uuid) {
    try {
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –≤ —á–µ—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫
        const result = await pool.query(
            'SELECT crypto_amount FROM shipments WHERE uuid = $1',
            [uuid]
        );
        const amount = parseFloat(result.rows[0].crypto_amount); // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ —ç—Ç–æ —á–∏—Å–ª–æ
        const roundedAmount = parseFloat(amount.toFixed(6));
        return roundedAmount
    } catch (error) {
        console.error('Error revoking token:', error);
        return { error: 'Failed to fetch amount' };
    }
};

async function getShipment(shipmentID) {
    try {
        const shipmentQuery = `
            SELECT 
                sh.id,
                sh.uuid,
                sh.company_id,
                sh.supplier_id,
                sh.fiat_amount,
                sh.fiat_currency,
                sh.crypto_amount,
                sh.status,
                sh.handler,
                sh.name AS shipment_name,
                sh.description AS shipment_description,
                sh.init,
                sh.created_at,
                sh.updated_at,
                s.name AS supplier_name,
                s.description AS supplier_description,
                c.name AS company_name
            FROM shipments sh
            JOIN suppliers s ON sh.supplier_id = s.id
            JOIN companies c ON sh.company_id = c.id
            WHERE sh.id = $1
        `;

        const result = await pool.query(shipmentQuery, [shipmentID]);
        
        if (result.rows.length === 0) {
            throw new Error('Shipment not found');
        }

        const shipmentDB = result.rows[0];
        console.log('Shipment from DB:', shipmentDB.uuid);
        const contractData = await contract.getShipment(shipmentDB.uuid);

        const transactionQuery = `
            SELECT 
                *
            FROM transactions
            WHERE shipment_id = $1
        `;

        const transactionsResult = await pool.query(transactionQuery, [shipmentID]);

        return { database: shipmentDB, blockchain: contractData.data, transactions: transactionsResult.rows };
    } catch (err) {
        console.error(err);
        throw err;
    }
}

async function checkSupplierWallet(supplierID) {
    try {
        const supplierQuery = `
            SELECT wallet_address FROM suppliers WHERE id = $1;
        `;
        const supplierResult = await pool.query(supplierQuery, [supplierID]);
        if (supplierResult.rows.length === 0) {
            return { error: 'Supplier not found' };
        }

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞
        return { walletAddress: supplierResult.rows[0].wallet_address };
    } catch (err) {
        console.error(err);
        return { error: 'Failed to fetch supplier wallet' };
    }
}

const getShipments = async (type, id, filters = {}) => {
    try {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Ç–∏–ø–∞
        if (type !== 'company' && type !== 'supplier') {
            throw new Error("Invalid type. Expected 'company' or 'supplier'.");
        }

        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        const filterColumn = type === 'company' ? 'c.id' : 's.id';

        // –ë–∞–∑–æ–≤—ã–π SQL-–∑–∞–ø—Ä–æ—Å —Å JOIN –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü
        let query = `
            SELECT 
                sh.id,
                sh.uuid,
                c.name AS company_name,
                s.name AS supplier_name,
                sh.status,
                sh.handler,
                sh.name AS shipment_name,
                sh.init,
                sh.created_at,
                sh.updated_at
            FROM shipments sh
            LEFT JOIN companies c ON sh.company_id = c.id
            LEFT JOIN suppliers s ON sh.supplier_id = s.id
            WHERE ${filterColumn} = $1
        `;

        // –ú–∞—Å—Å–∏–≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
        const queryParams = [id];
        let paramIndex = 2; // –ò–Ω–¥–µ–∫—Å –¥–ª—è –Ω–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 2, —Ç–∞–∫ –∫–∞–∫ $1 —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)

        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤
        if (filters.created_after) {
            query += ` AND sh.created_at >= $${paramIndex}`;
            queryParams.push(filters.created_after);
            paramIndex++;
        }

        if (filters.created_before) {
            query += ` AND sh.created_at <= $${paramIndex}`;
            queryParams.push(filters.created_before);
            paramIndex++;
        }

        if (filters.updated_after) {
            query += ` AND sh.updated_at >= $${paramIndex}`;
            queryParams.push(filters.updated_after);
            paramIndex++;
        }

        if (filters.updated_before) {
            query += ` AND sh.updated_at <= $${paramIndex}`;
            queryParams.push(filters.updated_before);
            paramIndex++;
        }

        if (filters.status) {
            query += ` AND sh.status = $${paramIndex}`;
            queryParams.push(filters.status);
            paramIndex++;
        }

        if (filters.handler) {
            query += ` AND sh.handler = $${paramIndex}`;
            queryParams.push(filters.handler);
            paramIndex++;
        }

        // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
        const result = await pool.query(query, queryParams);

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        return result.rows;
    } catch (error) {
        console.error('Error in getShipments:', error.message);
        throw error; // –ü–µ—Ä–µ–¥–∞–µ–º –æ—à–∏–±–∫—É –¥–∞–ª—å—à–µ
    }
};

async function getPaymentInfo(shipmentId) {
    try {
        // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Å—Ç–∞–≤–∫–µ
        const shipmentQuery = `
            SELECT 
                fiat_amount,
                crypto_amount,
                init
            FROM shipments 
            WHERE id = $1
        `;
        const result = await pool.query(shipmentQuery, [shipmentId]);
        
        if (result.rows.length === 0) {
            throw new Error('Shipment not found');
        }

        const shipment = result.rows[0];

        // –ï—Å–ª–∏ –ø–æ—Å—Ç–∞–≤–∫–∞ —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å—É–º–º—ã
        if (shipment.init) {
            return {
                success: true,
                data: {
                    payWallet: process.env.OUR_WALLET,
                    sendTrxSumm: shipment.crypto_amount,
                    sendUsdtSumm: shipment.fiat_amount,
                    message: '–ü–æ—Å—Ç–∞–≤–∫–∞ —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞'
                }
            };
        }

        // –ï—Å–ª–∏ –ø–æ—Å—Ç–∞–≤–∫–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞, –ø–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –∫—É—Ä—Å TRX
        await getTrxRate();
        const trxAmount = (parseFloat(shipment.fiat_amount) / TRX_RATE).toFixed(6);

        return {
            success: true,
            data: {
                payWallet: process.env.OUR_WALLET,
                sendTrxSumm: trxAmount,
                sendUsdtSumm: shipment.fiat_amount,
                message: '–û–∂–∏–¥–∞–µ—Ç—Å—è –æ–ø–ª–∞—Ç–∞'
            }
        };
    } catch (error) {
        console.error('Error getting payment info:', error);
        throw error;
    }
}

async function updateStatus(shipmentUuid, status, handler) {
    const statusQuery = `
        UPDATE shipments
        SET status = $1, handler = $2
        WHERE uuid = $3
        RETURNING *;
    `;
    try {
        const result = await pool.query(statusQuery, [status, handler, shipmentUuid]);
        if (result.rows.length === 0) {
            throw new Error('Shipment not found');
        }
        return result.rows[0]; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—É—é –∑–∞–ø–∏—Å—å
    } catch (error) {
        console.error(`Error updating shipment status:`, error);
        throw error;
    }
}

module.exports = {
    createCompany,
    createSupplier,
    createShipment,
    createTransaction,
    getCompaniesAndSuppliers,
    createEntity,
    revokeToken,
    getAmountByUuid,
    getShipments,
    getShipment,
    updateSupplierWallet,
    getCompaniesAndSuppliersForShipment,
    checkSupplierWallet,
    getEntityData,
    getPaymentInfo,
    updateStatus
};